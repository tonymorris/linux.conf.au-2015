\begin{frame}
\frametitle{Referential Transparency}
\begin{itemize}
  \item<1-> referential transparency is a decidable property of expressions
  \item<2-> functions provide programmers a tool to create referentially transparent expressions
\end{itemize}
\begin{block}<3>{The Test for Referential Transparency}
An expression \lstinline$expr$ is referentially transparent if in a program \lstinline$p$, all occurrences of \lstinline$expr$ in \lstinline$p$ can be replaced by an assignment to \lstinline$expr$ without effecting an observable change in \lstinline$p$.
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Referential Transparency}
\begin{block}<1>{Example program}
\begin{lstlisting}
p = {
  r = buffer.append(x)
  r = buffer.append(x)
  f(r, r)
}
\end{lstlisting}
\end{block}
\begin{block}<2>{Refactoring of program}
\begin{lstlisting}
p = {
  f(buffer.append(x), buffer.append(x))
}
\end{lstlisting}
\end{block}
\begin{block}<3>{}
Is the program refactoring observable for all values of \lstinline$f$?
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Referential Transparency}
\begin{block}<1>{Example program}
\begin{lstlisting}
p = {
  r = str.length()
  r = str.length()
  f(r, r)
}
\end{lstlisting}
\end{block}
\begin{block}<2>{Refactoring of program}
\begin{lstlisting}
p = {
  f(str.length(), str.length())
}
\end{lstlisting}
\end{block}
\begin{block}<3>{}
Is the program refactoring observable for all values of \lstinline$f$?
\end{block}
\end{frame}

\begin{frame}
\frametitle{Functional Programming}
\begin{itemize}
  \item<1-> FP is a commitment to preserving referential transparency
  \item<2-> Quite a while ago, FP won by not-a-little-bit. Moving on.
  \item<3-> we use tools to achieve this commitment
  \item<4-> parametricity is one such tool with high reward
\end{itemize}
\end{frame}
